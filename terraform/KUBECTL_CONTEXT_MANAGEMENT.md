# Kubectl Context Management for Diocesan Vitality

This document explains the enhanced Terraform configuration that automatically manages kubectl contexts for dev and staging clusters.

## Overview

When you create dev or staging clusters using Terraform, the system now automatically:

1. **Creates the cluster** using DigitalOcean Kubernetes
2. **Generates a kubeconfig file** for backup/manual use
3. **Adds a named context** to your local `~/.kube/config`
4. **Provides easy switching** between environments

## Features

### ✅ **Automatic Context Addition**
- Contexts are automatically added to your default kubectl configuration
- No need to manually manage multiple kubeconfig files
- Contexts are properly named for easy identification

### 🏷️ **Consistent Naming**
- **Development**: `diocesan-vitality-dev`
- **Staging**: `diocesan-vitality-staging`

### 🔄 **Easy Switching**
```bash
# Switch between environments
kubectl config use-context diocesan-vitality-dev
kubectl config use-context diocesan-vitality-staging

# Or use the helper script
./terraform/scripts/manage-contexts.sh dev
./terraform/scripts/manage-contexts.sh staging
```

### 🛡️ **Safe Operations**
- Automatic backup of existing kubeconfig before changes
- Clean removal of contexts when destroying clusters
- Fallback to traditional kubeconfig files if context addition fails

## Usage

### Creating Clusters with Context Management

```bash
# Create development cluster with automatic context
cd terraform/environments/dev
terraform apply

# Create staging cluster with automatic context  
cd terraform/environments/staging
terraform apply
```

The clusters will be created and contexts automatically added to your kubectl configuration.

### Using the Context Management Script

We've provided a helper script for easy context management:

```bash
# Show help
./terraform/scripts/manage-contexts.sh help

# List all contexts
./terraform/scripts/manage-contexts.sh list

# Show current context
./terraform/scripts/manage-contexts.sh current

# Switch to development
./terraform/scripts/manage-contexts.sh dev

# Switch to staging
./terraform/scripts/manage-contexts.sh staging

# Show status of all environments
./terraform/scripts/manage-contexts.sh status
```

### Manual Context Management

If you prefer manual control:

```bash
# List available contexts
kubectl config get-contexts

# Switch contexts
kubectl config use-context diocesan-vitality-dev
kubectl config use-context diocesan-vitality-staging

# Show current context
kubectl config current-context

# Test cluster connection
kubectl get nodes
```

## Configuration Options

### Module Variables

The `do-k8s-cluster` module now accepts these additional variables:

```hcl
module "k8s_cluster" {
  source = "../../modules/do-k8s-cluster"
  
  # ... other variables ...
  
  # Context management options
  add_kubectl_context  = true                    # Enable automatic context addition
  kubectl_context_name = "diocesan-vitality-dev" # Custom context name
}
```

### Available Variables

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `add_kubectl_context` | `bool` | `true` | Whether to add kubectl context to local machine |
| `kubectl_context_name` | `string` | `""` | Custom context name (defaults to cluster_name if empty) |
| `write_kubeconfig` | `bool` | `true` | Whether to write kubeconfig file locally (existing) |

### Terraform Outputs

New outputs provide context information:

```hcl
output "kubectl_context" {
  value = {
    name         = module.k8s_cluster.kubectl_context_name
    added        = module.k8s_cluster.kubectl_context_added
    switch_cmd   = "kubectl config use-context ${module.k8s_cluster.kubectl_context_name}"
  }
}
```

## How It Works

### 1. **Context Addition Process**
When `terraform apply` runs:

1. Cluster is created in DigitalOcean
2. Kubeconfig is generated by DigitalOcean API
3. A temporary kubeconfig file is created
4. The context is renamed to your specified name
5. Your existing `~/.kube/config` is backed up
6. The new context is merged into your default kubeconfig
7. Proper permissions are set on the config file

### 2. **Context Removal Process**
When `terraform destroy` runs:

1. Check if the context exists in kubectl config
2. If it's the current context, switch to another available context
3. Remove the context from kubectl configuration
4. Clean removal without affecting other contexts

### 3. **Backup Strategy**
- Automatic backup: `~/.kube/config.backup.YYYYMMDD_HHMMSS`
- Backups are created before any modifications
- Original kubeconfig files are preserved in Terraform directories

## Troubleshooting

### Context Not Added
If the automatic context addition fails:

```bash
# Check Terraform outputs
terraform output kubectl_context

# Manually add context using kubeconfig file
export KUBECONFIG=/path/to/kubeconfig-cluster-name
kubectl config view --flatten > ~/.kube/config.new
mv ~/.kube/config.new ~/.kube/config
```

### Context Already Exists
If a context with the same name exists:

```bash
# Remove existing context
kubectl config delete-context diocesan-vitality-dev

# Re-run terraform apply
terraform apply
```

### Connection Issues
If you can't connect to a cluster:

```bash
# Check available contexts
kubectl config get-contexts

# Test connection
kubectl get nodes

# Use context management script to diagnose
./terraform/scripts/manage-contexts.sh status
```

### Restore from Backup
If something goes wrong with your kubeconfig:

```bash
# List backups
ls ~/.kube/config.backup.*

# Restore from backup
cp ~/.kube/config.backup.YYYYMMDD_HHMMSS ~/.kube/config
```

## Migration from Previous Setup

If you were using the old kubeconfig file approach:

### Option 1: Let Terraform Handle It (Recommended)
Simply run `terraform apply` in your environment directories. The new system will:
- Add the context automatically
- Keep your existing kubeconfig files as backups
- Update deployment scripts to use the new approach

### Option 2: Manual Migration
If you prefer manual control:

```bash
# For development
cd terraform/environments/dev
kubectl config set-context diocesan-vitality-dev \
  --cluster=$(terraform output -raw cluster_info.name) \
  --user=$(terraform output -raw cluster_info.name)-admin \
  --namespace=default

# For staging  
cd terraform/environments/staging
kubectl config set-context diocesan-vitality-staging \
  --cluster=$(terraform output -raw cluster_info.name) \
  --user=$(terraform output -raw cluster_info.name)-admin \
  --namespace=default
```

## Best Practices

### 1. **Context Naming**
- Use consistent naming across environments
- Include project name in context names
- Use environment suffixes (-dev, -staging, -prod)

### 2. **Context Switching**
- Always verify current context before running kubectl commands
- Use the status script to check connections
- Switch contexts explicitly rather than relying on defaults

### 3. **Backup Management**
- Regularly clean up old kubeconfig backups
- Keep at least one recent backup
- Test backup restoration periodically

### 4. **Team Collaboration**
- Document context names for team members
- Use consistent naming across team environments
- Share the context management script with team members

## Security Considerations

### File Permissions
- Kubeconfig files are automatically set to `600` (owner read/write only)
- Backups maintain the same restrictive permissions
- Temporary files are cleaned up automatically

### Context Isolation
- Each environment gets its own isolated context
- No cross-environment configuration bleeding
- Clear separation between dev/staging/production

### Token Management
- Cluster tokens are managed by DigitalOcean
- Automatic token rotation supported
- No long-lived credentials stored locally

## Examples

### Complete Workflow
```bash
# Create development environment
cd terraform/environments/dev
terraform apply

# Switch to development context
kubectl config use-context diocesan-vitality-dev

# Deploy application
kubectl apply -f ../../k8s/

# Create staging environment
cd ../staging
terraform apply

# Switch to staging context
kubectl config use-context diocesan-vitality-staging

# Deploy to staging
kubectl apply -f ../../k8s/

# Check both environments
./terraform/scripts/manage-contexts.sh status
```

### Daily Operations
```bash
# Morning: Check what's available
./terraform/scripts/manage-contexts.sh list

# Switch to development for feature work
./terraform/scripts/manage-contexts.sh dev

# Test changes
kubectl get pods
kubectl logs -f deployment/app

# Switch to staging for testing
./terraform/scripts/manage-contexts.sh staging

# Verify staging deployment
kubectl get applications -n argocd
```

This enhanced kubectl context management makes it much easier to work with multiple Kubernetes environments while maintaining clear separation and easy switching between them.